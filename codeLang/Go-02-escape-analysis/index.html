<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【Go】02-逃逸分析(escape analysis)——未完 | cv-programmer</title><meta name="keywords" content="Go,逃逸"><meta name="author" content="cv-programmer"><meta name="copyright" content="cv-programmer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="引入C&#x2F;C++ 函数返回局部变量：在C&#x2F;C++中，一个函数可以直接返回函数中定义的局部变量，这里返回的是局部变量的副本（拷贝）。因为局部变量是分配在栈空间，因此在函数返回后，局部变量是被系统自动回收的， 函数返回局部变量地址：局部变量内存分配在栈空间，因为函数返回后，系统自动回收了函数里定义的局部变量，所以运行时去访问一个被系统回收后的地址空间，一定就会发生段错误，这是C&amp;#x">
<meta property="og:type" content="article">
<meta property="og:title" content="【Go】02-逃逸分析(escape analysis)——未完">
<meta property="og:url" content="http://bh.ecel.top/codeLang/Go-02-escape-analysis/index.html">
<meta property="og:site_name" content="cv-programmer">
<meta property="og:description" content="引入C&#x2F;C++ 函数返回局部变量：在C&#x2F;C++中，一个函数可以直接返回函数中定义的局部变量，这里返回的是局部变量的副本（拷贝）。因为局部变量是分配在栈空间，因此在函数返回后，局部变量是被系统自动回收的， 函数返回局部变量地址：局部变量内存分配在栈空间，因为函数返回后，系统自动回收了函数里定义的局部变量，所以运行时去访问一个被系统回收后的地址空间，一定就会发生段错误，这是C&amp;#x">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://bh.ecel.top/image/go.jpeg">
<meta property="article:published_time" content="2022-11-17T11:42:03.000Z">
<meta property="article:modified_time" content="2024-08-31T14:32:14.288Z">
<meta property="article:author" content="cv-programmer">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="逃逸">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://bh.ecel.top/image/go.jpeg"><link rel="shortcut icon" href="/image/avatar.jpg"><link rel="canonical" href="http://bh.ecel.top/codeLang/Go-02-escape-analysis/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":10,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-31 22:32:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/image/avatar.jpg" onerror="onerror=null;src='/image/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">93</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">126</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-lock"></i><span> 个人</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/timerest/"><i class="fa-fw fas fa-warning"></i><span> 倒计时</span></a></li><li><a class="site-page" href="/myweb/"><i class="fa-fw fas fa-database"></i><span> 网站</span></a></li><li><a class="site-page" href="/blogs/"><i class="fa-fw fas fa-file-text"></i><span> 博文</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/image/go.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">cv-programmer</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-lock"></i><span> 个人</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/timerest/"><i class="fa-fw fas fa-warning"></i><span> 倒计时</span></a></li><li><a class="site-page" href="/myweb/"><i class="fa-fw fas fa-database"></i><span> 网站</span></a></li><li><a class="site-page" href="/blogs/"><i class="fa-fw fas fa-file-text"></i><span> 博文</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Go】02-逃逸分析(escape analysis)——未完</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-17T11:42:03.000Z" title="发表于 2022-11-17 19:42:03">2022-11-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-31T14:32:14.288Z" title="更新于 2024-08-31 22:32:14">2024-08-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><h2 id="C-C"><a href="#C-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h2><ul>
<li>函数返回<code>局部变量</code>：在C&#x2F;C++中，一个函数可以直接返回函数中定义的局部变量，这里返回的是<strong>局部变量的副本（拷贝）</strong>。因为局部变量是分配在<code>栈空间</code>，因此在函数返回后，局部变量是被系统自动回收的，</li>
<li>函数返回<code>局部变量地址</code>：局部变量内存分配在栈空间，因为函数返回后，系统自动回收了函数里定义的局部变量，所以运行时去访问一个被系统回收后的地址空间，一定就会发生段错误，这是C&#x2F;C++语言的特点。内存空间分配在<code>堆空间</code>中即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">fun</span>();</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;		<span class="comment">// segment fault</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><ul>
<li>不同于C&#x2F;C++，Go中函数内部局部变量，无论是动态new出来的变量还是创建的局部变量，它被分配在堆还是栈，是由<strong>编译器</strong>做<code>逃逸分析(Escape Analysis)</code>之后做出的决定</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun</span><span class="params">()</span></span> *<span class="type">int</span> &#123; </span><br><span class="line">    tmp := <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &amp;tmp      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">    p = fun()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d&quot;</span>, *p) <span class="comment">//这里不会像C/C++，报错段错误提示，而是成功返回变量V的值1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go内存分配"><a href="#Go内存分配" class="headerlink" title="Go内存分配"></a>Go内存分配</h1><h2 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h2><ul>
<li>全局堆空间用来<strong>动态</strong>分配内存；堆区的内存一般由<strong>编译器和工程师</strong>自己共同进行管理分配，交给 <code>Runtime GC</code> 来释放</li>
<li>堆上分配必须找到一块足够大的内存来存放新的变量数据；后续释放时，垃圾回收器扫描堆空间寻找不再被使用的对象</li>
</ul>
<h2 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h2><ul>
<li>每个 <code>goroutine</code> 都有的自身栈空间</li>
<li>栈区的内存一般由<strong>编译器</strong>自动进行分配和释放，其中存储着函数的入参以及局部变量，这些参数会随着函数的创建而创建，函数的返回而销毁（即 CPU push &amp; release</li>
</ul>
<h2 id="分配规则"><a href="#分配规则" class="headerlink" title="分配规则"></a>分配规则</h2><ul>
<li><p><strong>由编译器做逃逸分析决定</strong></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://golang.google.cn/doc/faq#stack_or_heap">Go: Frequently Asked Questions (FAQ) </a></p>
<blockquote>
<p>How do I know whether a variable is allocated on the heap or the stack?</p>
<p>From a correctness standpoint, you don’t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.</p>
<p>The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function’s stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.</p>
<p>In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.</p>
</blockquote>
</li>
</ul>
<h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><strong>编译器</strong>决定内存分配位置的方式，就称之为<code>逃逸分析(escape analysis)</code>。逃逸分析由编译器完成，作用于<strong>编译阶段</strong></li>
<li>引起内存逃逸的关键：<strong>编译器在编译的时候无法确定确定变量的生命周期，只能在运行时控制了</strong></li>
<li>在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针；再往简单的说，Go是通过在编译器里做逃逸分析（escape analysis）来决定一个对象放栈上还是放堆上，<strong>不逃逸的对象放栈上，可能逃逸的放堆上</strong><ul>
<li>发现<code>变量</code>在退出函数后没有用了，那么就把丢到栈上，毕竟栈上的内存分配和回收比堆上快很多</li>
<li>函数内的普通变量经过<code>逃逸分析</code>后，发现在函数退出后<code>变量</code>还有在其他地方上引用，那就将<code>变量</code>分配在堆上。做到按需分配</li>
</ul>
</li>
</ul>
<h2 id="为什么需要逃逸分析"><a href="#为什么需要逃逸分析" class="headerlink" title="为什么需要逃逸分析"></a>为什么需要逃逸分析</h2><ul>
<li>减少 <code>GC</code> 压力，栈上的变量，随着函数退出后系统直接回收，不需要 <code>GC</code> 标记后再清除</li>
<li>减少内存碎片的产生</li>
<li>减轻分配堆内存的开销，提高程序的运行速度</li>
</ul>
<h2 id="查看对象是否发生逃逸"><a href="#查看对象是否发生逃逸" class="headerlink" title="查看对象是否发生逃逸"></a>查看对象是否发生逃逸</h2><ul>
<li><p>在<code>Go</code>中通过逃逸分析日志来确定变量是否逃逸，开启逃逸分析日志</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go build也可以</span></span><br><span class="line"><span class="keyword">go</span> run -gcflags <span class="string">&#x27;-m -l&#x27;</span> main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>-m</code> 会打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 <code>-m</code>，但是信息量较大，一般用 1 个就可以了</li>
<li><code>-l</code> 会禁用函数内联，在这里禁用掉<code>内联</code>能更好的观察逃逸情况，减少干扰</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun</span><span class="params">()</span></span> *<span class="type">int</span> &#123; </span><br><span class="line">    tmp := <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &amp;tmp      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun2</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	val := <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">    p = fun()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d&quot;</span>, *p)</span><br><span class="line">	t := fun2()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d&quot;</span>, t)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line"><span class="comment">./main.go:5:6: can inline fun</span></span><br><span class="line"><span class="comment">./main.go:10:6: can inline fun2</span></span><br><span class="line"><span class="comment">./main.go:17:12: inlining call to fun</span></span><br><span class="line"><span class="comment">./main.go:18:15: inlining call to fmt.Printf</span></span><br><span class="line"><span class="comment">./main.go:19:11: inlining call to fun2</span></span><br><span class="line"><span class="comment">./main.go:20:12: inlining call to fmt.Printf</span></span><br><span class="line"><span class="comment">./main.go:6:5: moved to heap: tmp</span></span><br><span class="line"><span class="comment">./main.go:18:15: ... argument does not escape</span></span><br><span class="line"><span class="comment">./main.go:18:22: *p escapes to heap</span></span><br><span class="line"><span class="comment">./main.go:20:12: ... argument does not escape</span></span><br><span class="line"><span class="comment">./main.go:20:13: t escapes to heap</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其中<code>moved to heap: tmp</code>和<code>xxx escapes to heap</code>即发生逃逸，分配在堆上</li>
</ul>
</li>
</ul>
<h2 id="引发逃逸的情形"><a href="#引发逃逸的情形" class="headerlink" title="引发逃逸的情形"></a>引发逃逸的情形</h2><ul>
<li><p>总结：<strong>多级间接赋值容易导致逃逸</strong></p>
<ul>
<li><p>这里的多级间接指的是，<strong>对某个引用类对象中的引用类成员进行赋值</strong>。Go 语言中的引用类数据类型有 <code>func</code>, <code>interface</code>, <code>slice</code>, <code>map</code>, <code>chan</code>, <code>*Type(指针)</code></p>
</li>
<li><p>记住公式 <code>Data.Field = Value</code>，如果 Data, Field 都是引用类的数据类型，则会导致 Value 逃逸。这里的等号 &#x3D; 不单单只赋值，也表示参数传递</p>
</li>
<li><p>假设一个变量 <code>data</code> 是以下几种类型，相应的可得出结论</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[]interface&#123;&#125;: data[0] = 100 会导致 100 逃逸</span><br><span class="line">map[string]interface&#123;&#125;: data[&quot;key&quot;] = &quot;value&quot; 会导致 &quot;value&quot; 逃逸</span><br><span class="line">map[interface&#123;&#125;]interface&#123;&#125;: data[&quot;key&quot;] = &quot;value&quot; 会导致 key 和 value 都逃逸</span><br><span class="line">map[string][]string: data[&quot;key&quot;] = []string&#123;&quot;hello&quot;&#125; 会导致切片逃逸</span><br><span class="line">map[string]*int: 赋值时 *int 会 逃逸</span><br><span class="line">[]*int: data[0] = &amp;i 会使 i 逃逸</span><br><span class="line">func(*int): data(&amp;i) 会使 i 逃逸</span><br><span class="line">func([]string): data([]&#123;&quot;hello&quot;&#125;) 会使 []string&#123;&quot;hello&quot;&#125; 逃逸</span><br><span class="line">chan []string: data &lt;- []string&#123;&quot;hello&quot;&#125; 会使 []string&#123;&quot;hello&quot;&#125; 逃逸</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="内存逃逸的弊端"><a href="#内存逃逸的弊端" class="headerlink" title="内存逃逸的弊端"></a>内存逃逸的弊端</h2><ul>
<li><p>提问：函数传递指针真的比传值效率高吗？</p>
</li>
<li><p>我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果<strong>拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的</strong></p>
</li>
</ul>
<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ul>
<li><input disabled type="checkbox"> 编译器如何实现逃逸分析</li>
<li><input disabled type="checkbox"> 逃逸与否的性能比较</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.huati365.com/566e3dfac2847178">Go语言—函数返回局部变量地址</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/863e64d72dd0">golang笔记——Goroutine栈与逃逸分析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenpingzhao/p/16759575.html">【Golang】关于Go语言中逃逸分析 </a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42849214/article/details/124478252">go 内存逃逸</a></li>
<li><a target="_blank" rel="noopener" href="https://mojotv.cn/2019/07/21/golang-escape">Go 逃逸分析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ling11/p/16318258.html">【详细】go内存逃逸</a></li>
</ol>
<h1 id="待看"><a href="#待看" class="headerlink" title="待看"></a>待看</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html">Language Mechanics On Escape Analysis</a></li>
<li><a target="_blank" rel="noopener" href="https://harveyli.me/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B1/">GO学习笔记之（一） Stack Or heap? 这是一个问题</a></li>
<li><a target="_blank" rel="noopener" href="https://geektutu.com/post/hpg-escape-analysis.html">Go 逃逸分析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sobyte.net/post/2021-12/golang-stack-management/">Stack memory and escape analysis in Go language</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-introduction-to-the-escape-analysis-f7610174e890">Go: Introduction to the Escape Analysis</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.devgenius.io/in-depth-analysis-of-golang-memory-escape-edfbfb856913">Golang Memory Escape In-Depth Analysis</a></li>
<li><a target="_blank" rel="noopener" href="https://mayurwadekar2.medium.com/escape-analysis-in-golang-ee40a1c064c1">Escape Analysis in Golang</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/69259045/why-the-below-two-code-cause-escape-in-golang">why the below two code cause escape in golang</a></li>
<li><a target="_blank" rel="noopener" href="https://www.qycn.com/xzx/article/7695.html">Golang的逃逸分析怎么实现，方法和操作是怎样</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">cv-programmer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://bh.ecel.top/codeLang/Go-02-escape-analysis/">http://bh.ecel.top/codeLang/Go-02-escape-analysis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://bh.ecel.top" target="_blank">cv-programmer</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a><a class="post-meta__tags" href="/tags/%E9%80%83%E9%80%B8/">逃逸</a></div><div class="post_share"><div class="social-share" data-image="/image/go.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/algorithm/lc-897-sum-of-subsequence-widths/"><img class="prev-cover" src="/image/lc.jpeg" onerror="onerror=null;src='/image/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【力扣】891.子序列宽度之和</div></div></a></div><div class="next-post pull-right"><a href="/tutorial/Linux-mount-a-new-disk/"><img class="next-cover" src="/image/linux.jpeg" onerror="onerror=null;src='/image/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Linux】挂载新硬盘</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/codeLang/Go-01-basic-concept/" title="【Go】01-基础概念"><img class="cover" src="/image/go.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-25</div><div class="title">【Go】01-基础概念</div></div></a></div><div><a href="/codeLang/Go-04-context/" title="【Go】04-context"><img class="cover" src="/image/go.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-04</div><div class="title">【Go】04-context</div></div></a></div><div><a href="/codeLang/Go-05-goroutine/" title="【Go】05-goroutine"><img class="cover" src="/image/go.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-03</div><div class="title">【Go】05-goroutine</div></div></a></div><div><a href="/codeLang/Go-03-gin/" title="【Go】03-Gin"><img class="cover" src="/image/go.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-30</div><div class="title">【Go】03-Gin</div></div></a></div><div><a href="/codeLang/Go-06-cobra/" title="【Go】06-Cobra"><img class="cover" src="/image/go.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-11</div><div class="title">【Go】06-Cobra</div></div></a></div><div><a href="/codeLang/Go-07-delve/" title="【Go】07-调试工具 delve"><img class="cover" src="/image/go.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-01</div><div class="title">【Go】07-调试工具 delve</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/image/avatar.jpg" onerror="this.onerror=null;this.src='/image/friend_404.gif'" alt="avatar"/><div class="author-info__name">cv-programmer</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">93</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">126</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cv-programmer"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cv-programmer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:usetologin@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">引入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-C"><span class="toc-number">1.1.</span> <span class="toc-text">C&#x2F;C++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go"><span class="toc-number">1.2.</span> <span class="toc-text">Go</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Go%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">2.</span> <span class="toc-text">Go内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4"><span class="toc-number">2.1.</span> <span class="toc-text">堆空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%A9%BA%E9%97%B4"><span class="toc-number">2.2.</span> <span class="toc-text">栈空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">2.3.</span> <span class="toc-text">分配规则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">逃逸分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">为什么需要逃逸分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%91%E7%94%9F%E9%80%83%E9%80%B8"><span class="toc-number">3.3.</span> <span class="toc-text">查看对象是否发生逃逸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%8F%91%E9%80%83%E9%80%B8%E7%9A%84%E6%83%85%E5%BD%A2"><span class="toc-number">3.4.</span> <span class="toc-text">引发逃逸的情形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">3.5.</span> <span class="toc-text">内存逃逸的弊端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TODO"><span class="toc-number">4.</span> <span class="toc-text">TODO</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%85%E7%9C%8B"><span class="toc-number">6.</span> <span class="toc-text">待看</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cloud/docker-02-multi-platform-image/" title="【Docker】02-多架构镜像构建"><img src="/image/docker.jpg" onerror="this.onerror=null;this.src='/image/404.jpg'" alt="【Docker】02-多架构镜像构建"/></a><div class="content"><a class="title" href="/cloud/docker-02-multi-platform-image/" title="【Docker】02-多架构镜像构建">【Docker】02-多架构镜像构建</a><time datetime="2025-11-15T14:28:40.000Z" title="发表于 2025-11-15 22:28:40">2025-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/interview/leetcode-go/" title="用 golang 刷leetcode"><img src="/image/knowledge.jpeg" onerror="this.onerror=null;this.src='/image/404.jpg'" alt="用 golang 刷leetcode"/></a><div class="content"><a class="title" href="/interview/leetcode-go/" title="用 golang 刷leetcode">用 golang 刷leetcode</a><time datetime="2025-09-14T12:52:51.000Z" title="发表于 2025-09-14 20:52:51">2025-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/tools/The-trick-of-ubuntu/" title="Ubuntu 常用技巧"><img src="/image/ubuntu.jpg" onerror="this.onerror=null;this.src='/image/404.jpg'" alt="Ubuntu 常用技巧"/></a><div class="content"><a class="title" href="/tools/The-trick-of-ubuntu/" title="Ubuntu 常用技巧">Ubuntu 常用技巧</a><time datetime="2025-05-11T03:17:02.000Z" title="发表于 2025-05-11 11:17:02">2025-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/ai/n8n/" title="工作流之 n8n"><img src="/image/n8n-logo.png" onerror="this.onerror=null;this.src='/image/404.jpg'" alt="工作流之 n8n"/></a><div class="content"><a class="title" href="/ai/n8n/" title="工作流之 n8n">工作流之 n8n</a><time datetime="2025-04-04T14:04:06.000Z" title="发表于 2025-04-04 22:04:06">2025-04-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/codeLang/Go-07-delve/" title="【Go】07-调试工具 delve"><img src="/image/go.jpeg" onerror="this.onerror=null;this.src='/image/404.jpg'" alt="【Go】07-调试工具 delve"/></a><div class="content"><a class="title" href="/codeLang/Go-07-delve/" title="【Go】07-调试工具 delve">【Go】07-调试工具 delve</a><time datetime="2025-03-01T14:41:51.000Z" title="发表于 2025-03-01 22:41:51">2025-03-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/image/go.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By cv-programmer</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>